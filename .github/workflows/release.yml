name: Release

on:
  push:
    branches:
      - main

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write

    env:
      PYPI_TOKEN: ${{ secrets.PYPI_API_TOKEN }}

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up uv
        uses: astral-sh/setup-uv@v1
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: uv sync --dev

      - name: Run tests
        run: uv run pytest

      - name: Build package
        run: uv build

      - name: Install release tooling
        run: python -m pip install keepachangelog tomlkit

      - name: Collect project metadata and verify PyPI availability
        id: metadata
        env:
          PYPI_TOKEN: ${{ env.PYPI_TOKEN }}
        run: |
          python - <<'PY'
import json
import os
import sys
import urllib.error
import urllib.request
from pathlib import Path

import tomlkit

pyproject = tomlkit.parse(Path("pyproject.toml").read_text(encoding="utf-8"))
project = pyproject["project"]
name = project["name"]
version = project["version"]

output_path = Path(os.environ["GITHUB_OUTPUT"])
with output_path.open("a", encoding="utf-8") as output:
    output.write(f"name={name}\n")
    output.write(f"version={version}\n")

if not os.environ.get("PYPI_TOKEN"):
    sys.exit(0)

url = f"https://pypi.org/pypi/{name}/json"
try:
    with urllib.request.urlopen(url) as response:
        data = json.load(response)
except urllib.error.HTTPError as exc:
    if exc.code == 404:
        sys.exit(0)
    raise
except urllib.error.URLError:
    sys.exit(0)

if version in data.get("releases", {}):
    print(f"Version {version} of {name} already exists on PyPI.")
    sys.exit(1)
PY

      - name: Publish to PyPI
        if: env.PYPI_TOKEN != ''
        env:
          UV_PUBLISH_TOKEN: ${{ env.PYPI_TOKEN }}
        run: uv publish --token "$UV_PUBLISH_TOKEN"

      - name: Extract current version release notes
        run: |
          python - <<'PY'
from pathlib import Path

from keepachangelog import to_dict

version = "${{ steps.metadata.outputs.version }}"
entries = to_dict("CHANGELOG.md")
entry = entries.get(version)
if entry is None:
    raise SystemExit(f"No release notes found for version {version} in CHANGELOG.md")

lines = []
metadata = entry.get("metadata", {})
header = version
release_date = metadata.get("release_date")
if release_date:
    header = f"{header} - {release_date}"
lines.append(f"## {header}")

known_sections = [
    "added",
    "changed",
    "deprecated",
    "removed",
    "fixed",
    "security",
]

def render_section(section_name: str) -> None:
    items = entry.get(section_name)
    if not items:
        return
    title = section_name.replace("_", " ").title()
    lines.append("")
    lines.append(f"### {title}")
    for item in items:
        lines.append(f"- {item}")

for section in known_sections:
    render_section(section)

other_sections = sorted(
    key for key in entry.keys()
    if key not in {"metadata", *known_sections}
)
for section in other_sections:
    render_section(section)

notes_path = Path(".github") / "current_release_notes.md"
notes_path.parent.mkdir(parents=True, exist_ok=True)
notes_path.write_text("\n".join(lines) + "\n", encoding="utf-8")
PY

      - name: Create GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.metadata.outputs.version }}
          name: v${{ steps.metadata.outputs.version }}
          body_path: .github/current_release_notes.md
          files: dist/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Clean up release notes
        if: always()
        run: rm -f .github/current_release_notes.md
